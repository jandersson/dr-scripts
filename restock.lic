# frozen_string_literal: true

#   Documentation: https://elanthipedia.play.net/Lich_script_repository#restock
custom_require.call(%w[common common-items common-money])
class Restock
  include DRC
  include DRCM
  include DRCI
  def initialize
    setup
    items = parse_restockable_items

    custom_loc_items = items.select { |k| k['hometown'] }

    items -= custom_loc_items
    restock_items(items, @settings.hometown)

    custom_loc_items.map { |k| k['hometown'] }.uniq
                    .each do |_hometown|
      custom_loc_items.group_by { |v| v['hometown'] }
                      .each { |hometown, items| restock_items(items, hometown) }
    end
  end

  def restock_items(item_list, town)
    items_to_restock = []
    coin_needed = 0

    item_list.each do |item|
      remaining = if item['stackable']
                    count_stackable_item(item['name'], item['container'])
                  else
                    count_nonstackable_item(item['name'], item['container'])
                  end
      next unless remaining < item['quantity']

      num_needed = item['quantity'] - remaining
      buy_num = (num_needed / item['size'].to_f).ceil
      coin_needed += buy_num * item['price']
      item['buy_num'] = buy_num
      items_to_restock.push(item)
    end
    get_money_from_specific_bank?("#{coin_needed} copper #{town_currency(town)}", town) if coin_needed > 0
    items_to_restock.each do |item|
      wait_for_script_to_complete('find', [item['wandering_npc']]) if item['wandering_npc']
      item['buy_num'].times do
        if item['wandering_npc']
          unless order_item?(item['wandering_npc'], item['order_number'])
            # If the npc moves, find it then attempt to buy again
            wait_for_script_to_complete('find', [item['wandering_npc']])
            order_item?(item['wandering_npc'], item['order_number'])
          end
        else
          buy_item(item['room'], item['name'])
        end
        fput("put my #{item['name']} in my #{item['container']}") if item['container'] && item['name']
        stow_hands
      end
    end
  end

  def order_item?(npc, order_number)
    case bput("order #{order_number} from #{npc}", 'You decide to purchase the', 'Order what', "You realize you don't have that much", "You can't order anything here")
    when "You can't order anything here", 'Order what'
      false
    else
      true
    end
  end

  def setup
    @settings = get_settings
    @restock = @settings.restock
    @hometown = @settings.hometown
    get_settings.storage_containers.each { |container| fput("open my #{container}") }
  end

  def parse_restockable_items
    item_list = @restock
    hometown_data = get_data('consumables')[@hometown]
    items = []
    item_list.each do |key, value|
      if hometown_data.key?(key) && !value.key?('hometown')
        ht_data = hometown_data[key]
        data = ht_data.each_key { |k| ht_data[k] = value[k] if value.key?(k) }
        items.push(data)
      elsif valid_item_data?(value)
        items.push(value)
      else
        echo "No hometown of explicit data for '#{key}'"
      end
    end
    items
  end

  def count_stackable_item(item, container)
    count = 0
    $ORDINALS.each do |ordinal|
      command = if container
                  "count my #{ordinal} #{item} in #{container}"
                else
                  "count my #{ordinal} #{item}"
                end
      count_msg = bput(command, 'I could not find what you were referring to.', 'tell you much of anything.', 'and see there \w+ .+ left.', 'It looks like there are \d+')
      case count_msg
      when 'I could not find what you were referring to.'
        break
      when 'tell you much of anything.'
        echo "#{item} is marked as stackable but is not!"
        count += count_nonstackable_item(item, container)
        break
      when /It looks like there are (\d+)/
        count += Regexp.last_match(1).to_i
      else
        count_txt = count_msg.match(/and see there \w+ (.+) left./).captures.first.tr('-', ' ')
        count += text2num(count_txt)
      end
      waitrt?
    end
    count
  end

  def count_nonstackable_item(item, container)
    unless container
      /inside your (.*).|I could not find/ =~ bput("tap my #{item}", 'inside your (.*).', 'I could not find')
      tap_result = Regexp.last_match(1)
      return 0 if tap_result.nil?

      container = tap_result
    end
    contents = bput("rummage /C #{item.split.last} IN MY #{container}", '^You rummage .*', "I don't know what you are referring to")
    contents.scan(/#{item}/).size
  end

  def valid_item_data?(item_data)
    return false unless item_data.key?('name')
    return false unless item_data.key?('size')
    return false unless item_data.key?('room') || item_data.key?('wandering_npc')
    return false unless item_data.key?('price')
    return false unless item_data.key?('stackable')
    return false unless item_data.key?('quantity')

    true
  end
end
Restock.new
