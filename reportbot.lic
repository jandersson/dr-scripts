=begin
  Documentation: https://elanthipedia.play.net/Lich_script_repository#reportbot
=end

class Reportbot
  def initialize
    @bad_words = get_data('bad-words').bad_words.sort
    echo("Initialized bad words; count: #{@bad_words.count}")

    fput('avoid !all')
  end

  def check_player(player)
    echo "checking player: #{player}"
    min_word = ''
    min_distance = 50
    @previous_word = nil
    # TODO: Trim row size to maximum character name length
    # TODO: Trim column size to maximum length of word in wordlist
    @d = Array.new(99) { Array.new(99) }
    (0..99).each do |i|
      @d[i][0] = i
      @d[0][i] = i
    end
    @bad_words.each do |word|
      distance = levenshtein_distance(player, word)
      if distance < min_distance
        min_distance = distance
        min_word = word
      end
      @previous_word = word
    end

    # TODO: The threshold here should really be a parameter to the distance function,
    #       so it can short circuit instead of running all possibilities
    #       Consider something like min_word = @bad_words.min { |word| levenshtein_distance(player, word) }
    if min_distance < 3
      echo "player: #{player}, word: #{min_word}, distance: #{min_distance}"
    end
  end

  def levenshtein_distance(s, t)
    m = s.length
    n = t.length
    offset = 1
    return m if n == 0
    return n if m == 0

    # Calculate offset (skip calculations for equal substrings, e.g.
    # if previous word was guitar and the current word is guilliotine, we can have
    # an offset of 3 for 'gui', we know these edit distances will be the same)
    unless @previous_word.nil?
      (0..t).each do |i|
        break unless i <= m
        if t[i] == s[i]
          offset += 1
        else
          break
        end
      end
    end

    # Compute distance table using Offset
    (offset..n).each do |j|
      (1..m).each do |i|
        @d[i][j] = if s[i-1] == t[j-1]  # adjust index into string
                    @d[i-1][j-1]       # no operation required
                  else
                    [ @d[i-1][j]+1,    # deletion
                      @d[i][j-1]+1,    # insertion
                      @d[i-1][j-1]+1,  # substitution
                    ].min
                  end
      end
    end
    @d[m][n]
  end
end

arg_definitions = [
  [
    { name: 'start', regex: /start/i, description: 'Required: prevents accidentally starting up reportbot' }
  ]
]

args = parse_args(arg_definitions)

start_script('playermonitor')
pause 1 until UserVars.players_online

reportbot = Reportbot.new
whitelist = load_reportbot_whitelist
echo whitelist

loop do
  (UserVars.players_online - whitelist)
    .each do |player|
      reportbot.check_player(player)
      whitelist << player
      save_reportbot_whitelist(whitelist)
    end

  pause 60
end
